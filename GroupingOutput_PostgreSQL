这里主要讲 NTH_VALUE, NTILE, LAG, LEAD 这几个语句

=====================================================================================================
首先来看表：

Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

创建表：
DROP TABLE IF EXISTS Runners;
CREATE TABLE Runners
  (name VARCHAR(20), weight INT, country VARCHAR(20), time INT);
INSERT INTO Runners
VALUES 
  ('andy', 50, 'UK', 101),
  ('bob', 100, 'UK', 103),
  ('cedric', 50, 'France', 104),
  ('dave', 70, 'Germany', 104),
  ('eric', 70, 'France', 108);
  
问题： 如何分别 用当前 行 与 当前行的前一行 进行比较？ 并 如何计算当前行 与前一行的差距？（这时候就可以用 LAG 和 LEAD）
说明：以上面的表 Runners 为例， 我们用当前行 与 前一行比较，当当前行 为 'andy'时，由于没有前一行，所以返回 None； 当当前行 为 'bob' 时，由于'bob' 的'time' 大于 'andy'，所以返回 'andy'的时间（较小的）
同理，我们也可以用 LEAD 来计算当前行 与前一行 的差。

-- 答案：
SELECT name, time, LAG(time, 1) OVER (ORDER BY time) AS time_of_person_ahead_of_me,
      LEAD(time, 1) OVER (ORDER BY time) - time AS how_much_i_was_ahead_of_the_person_behind_me
FROM Runners
ORDER BY time;

-- Output:
---------------------------------------------------------------------------------------------------
|    name   |    time     |time_of_person_ahead_of_me|how_much_i_was_ahead_of_the_person_behind_me|
---------------------------------------------------------------------------------------------------
|    andy   |     101     |           NULL           |                      2                     |
---------------------------------------------------------------------------------------------------
|    bob    |     103     |           101            |                      1                     |
---------------------------------------------------------------------------------------------------
|   cedric  |     104     |           103            |                      0                     |
---------------------------------------------------------------------------------------------------
|    dave   |     104     |           104            |                      0                     |
---------------------------------------------------------------------------------------------------
|    eric   |     108     |           104            |                     NULL                   |
---------------------------------------------------------------------------------------------------

同理， LAG 和 LEAD 后边括号中的 第二个参数可以变成 UNBOUNDED, PRECEDING 1, FOLLOWING 1, CURRENT ROW 等。


=====================================================================================================
再来看一下 NTH_VALUE 和 NTILE：

还是Runners表：
Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

问题：
1. 在 'time' 列 中，如何求出 该列中所有其他行 与 第二行（'bob'）的 差？
    说明： 由于 'andy' 领先 'bob'，所以二者的差 为 NULL。 对于其他行，如'dave' 与 'bob'的差为 -1
2. 在 'time' 列中，如何求出 该列中 第 n 小 的 值？
    说明， 当 n 为 1，则 NTH_VALUE(1) 返回 101。当 n 为 6 （超出范围），则 NTH_VALUE(6) 返回 NULL。
3. 在'time'列中，将所有的值 从小到大 平均分为 n 份，如何求出 当前行 的 'time'值 属于 这 n 份中的 第几份？
    说明， 如果将 'time' 列分为 2 份，则 前三行 是一份， 后两行 是一份。如果分为 4 份，则 前两行 是一份，后三行 分别是 第二、三、四 份。


-- 答案：
SELECT name, time,
  NTH_VALUE(time, 2) OVER (ORDER BY time) - time AS diff_between_current_and_nth_row,
  NTH_VALUE(time, 3) OVER (ORDER BY time) AS the_nth_smallest_value,
  NTILE(4) OVER (ORDER BY time) AS which_part
FROM Runners
ORDER BY time;

-- Output:
---------------------------------------------------------------------------------------------------
|    name   |     time    |diff_between_current_and_nth_row| the_nth_smallest_value | which_part  |
---------------------------------------------------------------------------------------------------
|    andy   |     101     |             NULL               |          104           |       1     |
---------------------------------------------------------------------------------------------------
|    bob    |     103     |              0                 |          104           |       1     |
---------------------------------------------------------------------------------------------------
|   cedric  |     104     |             -1                 |          104           |       2     |
---------------------------------------------------------------------------------------------------
|    dave   |     104     |             -1                 |          104           |       3     |
---------------------------------------------------------------------------------------------------
|    eric   |     108     |             -5                 |          104           |       4     |
---------------------------------------------------------------------------------------------------



