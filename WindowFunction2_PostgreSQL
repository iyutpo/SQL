这次将讲解 window function 中 用于返回 数字的 3个语句：
ROW_NUMBER, RANK, DENSE_RANK


===================================================================================================
先来看表：

Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

创建表：
DROP TABLE IF EXISTS Runners;
CREATE TABLE Runners
  (name VARCHAR(20), weight INT, country VARCHAR(20), time INT);
INSERT INTO Runners
VALUES 
  ('andy', 50, 'UK', 101),
  ('bob', 100, 'UK', 103),
  ('cedric', 50, 'France', 104),
  ('dave', 70, 'Germany', 104),
  ('eric', 70, 'France', 108);
  
  
问题：
1. 如何 根据 'time'列的升序， 对 Runners 表中的 各行 添加 行序号（行序号之间不能有重复）？ (ROW_NUMBER)
2. 如何 根据 'time'列的升序， 对 Runners 表中的 各行 添加 行序号（'time'相同的 行，序号要相同，且，如果出现并列的情况，如 3, 3，则这之后的 序号 为 5，而不是 4）？ (RANK)
3. 如何 根据 'time'列的升序， 对 Runners 表中的 各行 添加 行序号（'time'相同的 行，序号要相同，且，如果出现并列的情况，如 3, 3，则这之后的 序号 为 4，而不是 5）？ (DENSE_RANK)

我们来跑一下下面的代码，感受下区别：
SELECT name, time,
    ROW_NUMBER() OVER (ORDER BY time),
    RANK() OVER (ORDER BY time),
    DENSE_RANK() OVER (ORDER BY time),
FROM Runners ORDER BY time;

-------------------------------------------------------------------
|    name   |    time    |  ROW_NUMBER  |   RANK    | DENSE_RANK  |
-------------------------------------------------------------------
|    andy   |    101     |      1       |     1     |     1       |
-------------------------------------------------------------------
|    bob    |    103     |      2       |     2     |     2       |
-------------------------------------------------------------------
|   cedric  |    104     |      3       |     3     |     3       |
-------------------------------------------------------------------
|    dave   |    104     |      4       |     3     |     3       |
-------------------------------------------------------------------
|    eric   |    108     |      5       |     5     |     4       |
-------------------------------------------------------------------


===================================================================================================
再来看两个语句  CUME_DIST 和 PERCENT_RANK：
CUME_DIST：这个语句会返回 从 0 到 1 之间的某个数字（不包括 0），即 值域为： (0, 1]
PERCENT_RANK： 这个语句会返回 从 0 到 1 之间的某个数字， 值域为: [0, 1]
这两个语句 计算的都是 当前行 的 某个列（如 'time'列）在所有 'time' 中的 排名 的百分比。

来看个例子：
SELECT name, time,
CUME_DIST() OVER (ORDER BY time),
PERCENT_RANK() OVER (ORDER BY time)
FROM Runners
ORDER BY time;


Output:
--------------------------------------------------------
|    name   |    time    | PERCENT_RANK|   CUME_DIST   |
--------------------------------------------------------
|    andy   |    101     |      0      |      0.2      |
--------------------------------------------------------
|    bob    |    103     |     0.25    |      0.4      |
--------------------------------------------------------
|   cedric  |    104     |     0.5     |      0.8      |
--------------------------------------------------------
|    dave   |    104     |     0.5     |      0.8      |
--------------------------------------------------------
|    eric   |    108     |      1      |       1       |
--------------------------------------------------------

对于 CUME_DIST， 我们可以这样想： 由于 CUME_DIST 返回值的 值域为 (0, 1]，而'time'列中一共有 4 个unique的值（101, 103, 104, 108）所以我们将 (0, 1] 平均分为 4 + 1 份 （4 是有几个unique值，1是值域上界） = 5 份； 1 ÷ 5 = 0.2，从而最小的'time'值就是0.2， 次最小的 'time'就是0.4，以此类推，最大的'time'就是 1。
对于PERCENT_RANK，我们这样想： 由于 PERCENT_RANK 的值域为 [0, 1]，所以我们将 最小最大的 'time' 分别定义为 0 和 1。接着，由于一共有 4 个 unique的'time'值，所以将 [0, 1] 均分为 4 份，从而 次最小的 'time' (103) 就是 1 ÷ 4 = 0.25，以此类推，104 就是 0.5。注意，因为出现了两个 104，也就是会有两个 0.5，所以在'eric'行 就不会返回 0.75，而是直接返回 1。










