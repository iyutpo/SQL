该文件中将讲述 FILTER, WINDOW, 和 ARRAY_AGG 三个语句

来看一个表 Runners：
Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

创建表：
DROP TABLE IF EXISTS Runners;
CREATE TABLE Runners
  (name VARCHAR(20), weight INT, country VARCHAR(20), time INT);
INSERT INTO Runners
VALUES 
  ('andy', 50, 'UK', 101),
  ('bob', 100, 'UK', 103),
  ('cedric', 50, 'France', 104),
  ('dave', 70, 'Germany', 104),
  ('eric', 70, 'France', 108);

问题：如何从Runners表中选出 每个国家 选手们的 平均时间，然后根据 每个选手的平均时间，挑选出 体重小于90kg 的选手 作为 'light_runners_time'列。
说明： 对于 UK, 平均时间为 (101 + 103) / 2 = 102，记为 'avg_time'列。 由于'bob'超过 90kg，所以 'light_runners_time'列中，先去掉 'bob'，然后求平均为： (101) / 1 = 101。

-- Expected Output：
-----------------------------------------------
|    country    | avg_time |light_runners_time|
-----------------------------------------------
|      UK       |   102    |       101        |
-----------------------------------------------
|    France     |   106    |       106        |
-----------------------------------------------
|    Germany    |   104    |       104        |
-----------------------------------------------


-- 答案：
SELECT country,
    AVG(time) as avg_time,
    AVG(time) FILTER (WHERE weight < 90) AS light_runners_time
FROM Runners
GROUP BY country;


=======================================================================================================
WINDOW
这条语句不是很常见，但有的时候很实用。假设有如下一个场景：

Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

我们想要三列数据，这三列数据 所使用的 语句都是 window function 中的 NTILE(n) 
（NTILE(n)：将某一列从小到大平均分为 n 份，并返回当前行所属于 第几份。）
详见：https://github.com/iyutpo/SQL/blob/master/GroupingOutput_PostgreSQL

所以比较直接的方法就是 重复写 3 次 NTILE(n)，即：
SELECT name, time, 
NTILE(2) OVER (ORDER BY time ASC) AS by_half,
NTILE(3) OVER (ORDER BY time ASC) AS thirds,
NTILE(4) OVER (ORDER BY time ASC) AS quart
FROM Runners 
ORDER BY time;

--Expected Output:
--------------------------------------------------------------
|    name   |   time   |    by_half   |   third   |   quart  |
--------------------------------------------------------------
|    andy   |    101   |       1      |     1     |     1    |
--------------------------------------------------------------
|    bob    |    103   |       1      |     1     |     1    |
--------------------------------------------------------------
|   cedric  |    104   |       1      |     2     |     2    |
--------------------------------------------------------------
|    dave   |    104   |       2      |     2     |     3    |
--------------------------------------------------------------
|    eric   |    108   |       2      |     3     |     4    |
--------------------------------------------------------------

但是如果我们 要调用 NTILE(n) 很多次，并且 OVER 后边括号内的语句很长的话，就会很麻烦。所以这时就可以用 WINDOW 语句：

SELECT name, time, 
NTILE(2) OVER ntile_window AS by_half, 
NTILE(3) OVER ntile_window AS thirds, 
NTILE(4) OVER ntile_window AS quart 
FROM Runners 
WHERE time > 0              --这行没有影响输出结果，只是为了说明 WHERE 和 WINDOW 语句的顺序
WINDOW ntile_window AS (ORDER BY weight) 
ORDER BY weight, time

(上面的  'ntile_window' 就是用户自己定义的 一个新的 window function 。效果与 写三次 NTILE(n) 是一样的。）
***!!!（WINDOW 的本质 是 帮助用户 将 多个 OVER() 括号中的 重复的语句 进行打包， 减少代码量）!!!***


=======================================================================================================
ARRAY_AGG
这条语句 并不属于 window function，但比较有趣，所以想讲讲。另外严格意义上，ARRAY_AGG 应该属于 aggregate function，所以常与 GROUP BY 一起用。
ARRAY_AGG 可以帮我们 将若干个 数据 转换成一个 数组（array）。

例如，对于Runners表：
Runners:
-------------------------------------------------------
|    name   |   weight   |    country    |    time    |
-------------------------------------------------------
|    andy   |     50     |      UK       |    101     |
-------------------------------------------------------
|    bob    |     100    |      UK       |    103     |
-------------------------------------------------------
|   cedric  |     50     |    France     |    104     |
-------------------------------------------------------
|    dave   |     70     |    Germany    |    104     |
-------------------------------------------------------
|    eric   |     50     |    France     |    108     |
-------------------------------------------------------

我们想将所有的 'time' 列的数据变成一个 数组的形式，该怎么做？

-- Expected Output：
------------------------------
|         array_agg          |
------------------------------
| {101, 103, 104, 104, 108}  |
------------------------------


-- 答案：
SELECT ARRAY_AGG(time)
FROM Runners;








