假设现在我们有一个表(Cats):

Cats:
---------------------------------------------------------------------------
|     name        |   breed     |    weight   |    color     |     age     |
---------------------------------------------------------------------------
|    ashes	  |   persian   |     4.5     |    black     |      5      |
---------------------------------------------------------------------------
|    molly	  |   persian   |     4.2     |    black     |      1      |
---------------------------------------------------------------------------
|    felix	  |   british   |     4.9     | tortoiseshell|      2      |
---------------------------------------------------------------------------
|    smudge	  |   british   |     4.9     |    black     |      4      |
---------------------------------------------------------------------------
|    tigger	  |   british   |     3.8     | tortoiseshell|      2      |
---------------------------------------------------------------------------
|    alfie	  |   siamese   |     5.5     |    brown     |      5      |
---------------------------------------------------------------------------
|    oscar	  |   siamese   |     6.1     |    black     |      1      |
---------------------------------------------------------------------------
|    millie	  | maine coon  |     5.4     | tortoiseshell|      5      |
---------------------------------------------------------------------------
|    puss 	  | maine coon  |     5.7     |    brown     |      2      |
---------------------------------------------------------------------------
|    smokey	  | maine coon  |     5.1     | tortoiseshell|      2      |
---------------------------------------------------------------------------
|    charlie      |   british   |     4.8     |    black     |      4      |
---------------------------------------------------------------------------

在PgAdmin4中创建上面的表：
DROP TABLE IF EXISTS Cats;
CREATE TABLE Cats
  (name varchar(20), breed varchar(20), weight float, color varchar(20), age int);
INSERT INTO Cats
VALUES
  ('ashes', 'persian', 4.5, 'black', 5),
  ('molly', 'persian', 4.2, 'black', 1),
  ('felix', 'british', 4.9, 'tortoiseshell', 2),
  ('smudge', 'british', 4.9, 'black', 4),
  ('tigger', 'british', 3.8, 'tortoiseshell', 2),
  ('alfie', 'siamese', 5.5, 'brown', 5),
  ('oscar', 'simaese', 6.1, 'black', 1),
  ('millie', 'maine coon', 5.4, 'tortoiseshell', 5),
  ('puss', 'maine coon', 5.7, 'brown', 2),
  ('smokey', 'maine coon', 5.1, 'tortoiseshell', 2),
  ('charlie', 'british', 4.8, 'black', 4);


=====================================================================================================
Basic OVER
OVER 语句 在对aggregate function （如avg，sum，count等）进行限制的时候 非常常用。
假设有这样一个问题：
我们每得到一行数据，就对包括该行数据在内的所有行数据 按照 age列 取平均。并将最终的结果按照 name 列的字母序输出？

说明：例如，按照字母序，我们先要加入 'alfie' 这行，然后对 age列 取平均： 5÷1=5 （age ÷ 当前的行数）
然后加入 'ashes' 这行，然后对 age列 取平均： (5 + 5) ÷ 2 = 5 （alfie的 age + ashes的 age） ÷ 当前的行数
......
直到输出最后 的 'tigger'行（字母序最后一行）为止。

SELECT name, age, AVG(age) OVER (ORDER BY name)
FROM Cats;


=====================================================================================================
PARTITION BY
PARTITION BY可以让我们对 OVER 函数进行 进一步的分割和筛选



假设我们有如下一个表（Runners）：

Runners:
------------------------------------------
|    name   |   weight   |    country    |
------------------------------------------
|    andy   |     50     |      UK       |
------------------------------------------
|    bob    |     100    |      UK       |
------------------------------------------
|   cedric  |     50     |    France     |
------------------------------------------
|    dave   |     70     |    Germany    |
------------------------------------------
|    eric   |     50     |    France     |
------------------------------------------

创建表：
DROP TABLE IF EXISTS Runners;
CREATE TABLE Runners
  (name varchar(20), weight int, country varchar(20));
INSERT INTO Runners
VALUES 
  ('andy', 50, 'UK'),
  ('bob', 100, 'UK'),
  ('cedric', 50, 'France'),
  ('dave', 70, 'Germany'),
  ('eric', 70, 'France');




Partition by allows us to further subdivide the preceding Over Command

Here avg_weight is recomputed on every 'step' of the SQL like above BUT it is reset when the partition by field changes.

In this case we partition by country (think of it as grouping by country). There is a different aggregate function for each country





Think of over as like a running total. For instance in our runners table, we have a query that selects name and average weight of all the runners seen so far when ordered by name. Here average_weight is recomputed on each 'step' of the SQL output

select
name, weight,
avg(weight) over (order by name)
from runners order by name
limit 3
